<?php

namespace Omnipay\NSWGOVCPP\Tests;

use Firebase\JWT\JWT;
use Omnipay\Tests\GatewayTestCase;
use Omnipay\NSWGOVCPP\Gateway;
use Omnipay\NSWGOVCPP\ParameterStorage;
use Omnipay\NSWGOVCPP\AccessTokenRequestException;
use Omnipay\NSWGOVCPP\CompleteAccessTokenRequestException;
use Omnipay\NSWGOVCPP\CompletePurchaseRequestException;
use Omnipay\NSWGOVCPP\RefundRequestException;
use Omnipay\NSWGOVCPP\PaymentCompletionException;
use Omnipay\NSWGOVCPP\UnprocessableEntityException;
use Omnipay\NSWGOVCPP\AccessTokenRequest;
use Omnipay\NSWGOVCPP\AccessTokenResponse;
use Omnipay\NSWGOVCPP\CompleteAccessTokenRequest;
use Omnipay\NSWGOVCPP\CompleteAccessTokenResponse;
use Omnipay\NSWGOVCPP\CompletePurchaseRequest;
use Omnipay\NSWGOVCPP\CompletePurchaseResponse;
use Omnipay\NSWGOVCPP\RefundRequest;
use Omnipay\NSWGOVCPP\RefundResponse;
use Omnipay\NSWGOVCPP\AccessToken;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Response;

class GatewayTest extends GatewayTestCase {

    /** @var  Gateway */
    protected $gateway;

    /**
     * @var string
     */
    protected $jwtAlgo = 'RS256';

    /**
     * @var string
     */
    protected $jwt = '';

    public function setUp()
    {
        parent::setUp();
        // configure the gateway
        ParameterStorage::setAll( $this->getTestParameters() );
        // create and initialize with default params from ParameterStorage
        $this->gateway = new Gateway($this->getHttpClient(), $this->getHttpRequest());
    }

    /**
     * Get the test payment request payload
     */
    protected function getPaymentRequestPayload() : array {
        $payload = json_decode( trim( file_get_contents( dirname(__FILE__) . '/Mock/PaymentRequest.payload' ) ), true, JSON_THROW_ON_ERROR );
        return $payload;
    }

    /**
     * Get the test JWT payload and reate the JWT
     */
    protected function getJwtPayload() : object {
        $payload = json_decode( trim( file_get_contents( dirname(__FILE__) . '/Mock/JWT.payload' ) ), false, JSON_THROW_ON_ERROR );
        $payload->exp = time() + 300;
        // create a JWT with a non expired payload
        $this->jwt = JWT::encode($payload, $this->getJwtKey(), $this->jwtAlgo);
        return $payload;
    }

    /**
     * Get the test JWT key
     */
    protected function getJwtKey() : string {
        return trim(file_get_contents( dirname(__FILE__) . '/Mock/JWT.privatekey' ));
    }

    /**
     * Get the test JWT public key
     */
    protected function getJwtPublicKey() : string {
        return trim(file_get_contents( dirname(__FILE__) . '/Mock/JWT.publickey' ));
    }

    /**
     * Get the test JWT token, this was generated by:
     * `JWT::encode($this->getjwtPayload(), $this->getJwtKey(), $this->jwtAlgo);`
     */
    protected function getJwt() : string {
        return $this->jwt;
    }

    protected function getTestParameters() {
        return [
            'clientId' => 'testClientId',
            'clientSecret' => 'testClientSecret',
            'jwtPublicKey' => $this->getJwtPublicKey(),
            'accessTokenUrl' => 'https://localhost/accesstoken',
            'requestPaymentUrl' => 'https://localhost/paymentrequest',
            'gatewayUrl' => 'https://localhost/gateway',
            'refundUrl' => 'https://localhost/refund'
        ];
    }

    protected function getAccessToken() : AccessToken {
        $params = $this->getTestParameters();

        // authorize and get an access token
        $this->setMockHttpResponse('AccessTokenSuccess.response');

        $request = $this->gateway->authorize();
        $this->assertInstanceOf(AccessTokenRequest::class, $request);
        $data = $request->getData();

        $this->assertEquals($params['clientId'], $data['client_id']);
        $this->assertEquals($params['clientSecret'], $data['client_secret']);
        $this->assertEquals(AccessTokenRequest::OAUTH2_GRANT_CLIENT_CREDENTIALS, $data['grant_type']);
        // send the request
        $response = $request->send();
        $this->assertInstanceOf(AccessTokenResponse::class, $response);
        // get the access token
        $accessToken = $response->getAccessToken();
        $accessToken->setExpires( (time() + 300) );//bump the expiry
        $this->assertFalse($accessToken->isExpired(), "Access token has expired:" . time() . ">" . $accessToken->getExpires());
        $this->assertEquals("daarhmehearties", $accessToken->getToken());

        return $accessToken;
    }

    /**
     * Verify our JWT encode/decode is working using the Mock key, payload and token created initially
     */
    public function testJwt() {
        $payload = $this->getJwtPayload();
        $jwt = JWT::encode($payload, $this->getJwtKey(), $this->jwtAlgo);
        $this->assertEquals( $this->getJwt(), $jwt );
        $key = $this->getJwtPublicKey();
        $result = JWT::decode($jwt, $key, [ $this->jwtAlgo ]);
        $this->assertEquals($payload, $result);
    }

    public function testDoAuthorise()
    {
        $this->getAccessToken();
    }

    /**
     * When a payment request was made, we will get a payment reference
     */
    public function testDoPaymentRequest()
    {
        $accessToken = $this->getAccessToken();
        $payload = $this->getPaymentRequestPayload();
        $this->assertTrue(is_array($payload ));

        $completeAccessTokenRequest = $this->gateway->completeAuthorize([
            'accessToken' => $accessToken,/* @var AccessToken */
            'payload' => $payload
        ]);

        $this->assertInstanceOf(CompleteAccessTokenRequest::class, $completeAccessTokenRequest);

        $this->setMockHttpResponse('PaymentRequestSuccess.response');

        $data = $completeAccessTokenRequest->getData();

        $this->assertEquals($payload, $data, "Data is not equal to payload");

        $completeAccessTokenResponse = $completeAccessTokenRequest->send();
        $this->assertInstanceOf(CompleteAccessTokenResponse::class, $completeAccessTokenResponse);

        $paymentReference = $completeAccessTokenResponse->getPaymentReference();
        $duplicate = $completeAccessTokenResponse->isDuplicate();
        $this->assertEquals("here-be-monsters", $paymentReference);
        $this->assertFalse($duplicate);

        $redirectUrl = $completeAccessTokenResponse->getRedirectUrl();
        $this->assertNotEmpty($redirectUrl);

        $parts = parse_url($redirectUrl);
        parse_str($parts['query'], $query);
        $this->assertEquals($paymentReference, $query['paymentReference']);

        $redirectResponse = $completeAccessTokenResponse->getRedirectResponse();
        $this->assertInstanceOf(RedirectResponse::class, $redirectResponse);
        $this->assertEquals(Response::HTTP_FOUND, $redirectResponse->getStatusCode());
        $this->assertEquals($completeAccessTokenResponse->getRedirectUrl(), $redirectResponse->getTargetUrl());
        $redirectResult = $completeAccessTokenResponse->redirect();
        $this->assertEmpty($redirectResult);

    }

    /**
     * Test CompletePurchaseRequest, to verify an incoming JWT from the CPP
     */
    public function testDoPaymentComplete() {
        $payload = $this->getJwtPayload();
        $jwt = $this->getJwt();

        $this->assertNotEmpty($jwt, "No JWT to test with");

        $completePurchaseRequest = $this->gateway->completePurchase([
            'jwt' => $jwt
        ]);

        // ensure the token matches
        $this->assertEquals($jwt, $completePurchaseRequest->getJwt());
        // ensure the key matches
        $this->assertEquals($this->getJwtPublicKey(), $completePurchaseRequest->getJwtPublicKey());

        $completePurchaseResponse = $completePurchaseRequest->send();
        $this->assertInstanceOf(CompletePurchaseResponse::class, $completePurchaseResponse);

        $callback = function(CompletePurchaseResponse $response) {
            return true;
        };
        $complete = $completePurchaseResponse->complete($callback);
        $result = $complete->send();
    }

    public function testDoRefund() {

        $accessToken = $this->getAccessToken();

        // perform a refund

        $this->setMockHttpResponse('RefundSuccess.response');

        $refundAmount = 105;
        $refundReason = "test refund reason";
        $refundRequest = $this->gateway->refund([
            'accessToken' => $accessToken,/* @var AccessToken */
            'refundAmount' => $refundAmount,
            'refundReason' => $refundReason
        ]);
        $this->assertInstanceOf(RefundRequest::class, $refundRequest);

        $data = $refundRequest->getData();
        $this->assertEquals($refundAmount, $data['amount']);
        $this->assertEquals($refundReason, $data['refundReason']);

        $refundResponse = $refundRequest->send();
        $this->assertInstanceOf(RefundResponse::class, $refundResponse);

        $refundReference = $refundResponse->getRefundReference();
        $this->assertEquals("it_be_received", $refundReference);
    }

}
