<?php

namespace Omnipay\NSWGOVCPP\Tests;

use Firebase\JWT\JWT;
use Omnipay\Tests\GatewayTestCase;
use Omnipay\NSWGOVCPP\AccessToken;
use Omnipay\NSWGOVCPP\AccessTokenRequestException;
use Omnipay\NSWGOVCPP\CompletePurchaseRequest;
use Omnipay\NSWGOVCPP\CompletePurchaseResponse;
use Omnipay\NSWGOVCPP\CompletePurchaseRequestException;
use Omnipay\NSWGOVCPP\Gateway;
use Omnipay\NSWGOVCPP\JWTProcessor;
use Omnipay\NSWGOVCPP\ParameterStorage;
use Omnipay\NSWGOVCPP\PaymentCompletionException;
use Omnipay\NSWGOVCPP\PurchaseRequest;
use Omnipay\NSWGOVCPP\PurchaseResponse;
use Omnipay\NSWGOVCPP\RefundRequest;
use Omnipay\NSWGOVCPP\RefundResponse;
use Omnipay\NSWGOVCPP\FetchTransactionRequest;
use Omnipay\NSWGOVCPP\FetchTransactionResponse;
use Omnipay\NSWGOVCPP\RefundRequestException;
use Omnipay\NSWGOVCPP\UnprocessableEntityException;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Response;

class GatewayTest extends GatewayTestCase
{

    /** @var  Gateway */
    protected $gateway;

    /**
     * @var string
     */
    protected $jwtAlgo = 'RS256';

    /**
     * @var string
     */
    protected $jwt = '';

    public function setUp()
    {
        parent::setUp();
        // configure the gateway
        ParameterStorage::setAll($this->getTestParameters());
        // create and initialize with default params from ParameterStorage
        $this->gateway = new Gateway($this->getHttpClient(), $this->getHttpRequest());
    }

    /**
     * Get the test payment request payload
     */
    protected function getPaymentRequestPayload() : array
    {
        $payload = json_decode(trim(file_get_contents(dirname(__FILE__) . '/Mock/PaymentRequest.payload')), true, JSON_THROW_ON_ERROR);
        return $payload;
    }

    /**
     * Get the test JWT payload and create the JWT
     */
    protected function getJwtPayload() : object
    {
        $payload = json_decode(trim(file_get_contents(dirname(__FILE__) . '/Mock/JWT.payload')), false, JSON_THROW_ON_ERROR);
        $payload->exp = time() + 300;
        // create a JWT with a non expired payload
        $this->jwt = JWT::encode($payload, $this->getJwtPrivateKey(), $this->jwtAlgo);
        return $payload;
    }

    /**
     * Get the test JWT key
     */
    protected function getJwtPrivateKey() : string
    {
        return trim(file_get_contents(dirname(__FILE__) . '/Mock/JWT.privatekey'));
    }

    /**
     * Get the test JWT public key
     */
    protected function getJwtPublicKey() : string
    {
        return trim(file_get_contents(dirname(__FILE__) . '/Mock/JWT.publickey'));
    }

    /**
     * Get the test JWT token, this was generated by:
     * `JWT::encode($this->getjwtPayload(), $this->getJwtPrivateKey(), $this->jwtAlgo);`
     */
    protected function getJwt() : string
    {
        return $this->jwt;
    }

    protected $refundUrl = 'https://api-psm.g.testservicensw.net/cpp-digital/api/payments/{{paymentReference}}/refund';
    protected $statusUrl = 'https://api-psm.g.testservicensw.net/cpp-digital/api/payments/{{paymentReference}}/status';

    /**
     * Default Parameters used on the gateway
     */
    protected function getTestParameters() : array
    {
        return [
            'clientId' => 'testClientId',
            'clientSecret' => 'testClientSecret',
            'jwtPublicKey' => $this->getJwtPublicKey(),
            'accessTokenUrl' => 'https://localhost/accesstoken',
            'requestPaymentUrl' => 'https://localhost/paymentrequest',
            'gatewayUrl' => 'https://localhost/gateway',
            'refundUrl' => $this->refundUrl,
            'statusUrl' => $this->statusUrl,
            'paymentReference' => 'here-be-monsters' // this is required for base Omnipay tests
        ];
    }

    /**
     * Create and validate OAuth2 access token creation
     */
    protected function getAccessToken() : AccessToken
    {
        $payload = json_decode(trim(file_get_contents(dirname(__FILE__) . '/Mock/AccessToken.payload')), true, JSON_THROW_ON_ERROR);
        $this->assertArrayHasKey('expires', $payload);
        $this->assertArrayHasKey('token_type', $payload);
        $this->assertArrayHasKey('access_token', $payload);
        $expires = $payload['expires'] + time() + 3600;
        $accessToken = new AccessToken($payload['access_token'], $expires, $payload['token_type']);
        $this->assertInstanceOf(AccessToken::class, $accessToken);
        $this->assertTrue($accessToken->isValid());
        return $accessToken;
    }

    /**
     * Verify our JWT encode/decode is working using the Mock key, payload and token created initially
     */
    public function testJwt()
    {
        $payload = $this->getJwtPayload();
        $jwt = JWT::encode($payload, $this->getJwtPrivateKey(), $this->jwtAlgo);
        $this->assertEquals($this->getJwt(), $jwt);
        $key = $this->getJwtPublicKey();
        $result = JWT::decode($jwt, $key, [ $this->jwtAlgo ]);
        $this->assertEquals($payload, $result);
    }

    /**
     * Test CPP access token creation and validation
     */
    public function testCreateCppAccessToken()
    {
        $this->getAccessToken();
    }

    /**
     * When a payment request was made, we will get a payment reference
     */
    public function testDoCppPurchase()
    {
        $accessToken = $this->getAccessToken();

        $payload = $this->getPaymentRequestPayload();
        $this->assertTrue(is_array($payload));

        $purchaseRequest = $this->gateway->purchase([
            'payload' => $payload
        ]);
        $this->assertInstanceOf(PurchaseRequest::class, $purchaseRequest);

        // use the test token just created
        $purchaseRequest->setCurrentAccessToken($accessToken);

        // validate data
        $data = $purchaseRequest->getData();
        $this->assertEquals($payload, $data, "Payment request data is not equal to payment request payload");

        // set a mock payment request response
        $this->setMockHttpResponse('PaymentRequestSuccess.response');

        // send the reques
        $purchaseResponse = $purchaseRequest->send();
        $this->assertInstanceOf(PurchaseResponse::class, $purchaseResponse);

        // validate payment reference
        $paymentReference = $purchaseResponse->getPaymentReference();
        $duplicate = $purchaseResponse->isDuplicate();
        $this->assertEquals("here-be-monsters", $paymentReference);
        $this->assertFalse($duplicate);

        // validate gateway url
        $redirectUrl = $purchaseResponse->getRedirectUrl();
        $this->assertNotEmpty($redirectUrl);
        // grab paymentReference from the arg in the redirect to gateway URL
        $parts = parse_url($redirectUrl);
        $this->assertArrayHasKey('query', $parts);
        parse_str($parts['query'], $query);
        $this->assertArrayHasKey('paymentReference', $query);
        $this->assertEquals($paymentReference, $query['paymentReference']);

        // validate redirect response
        $redirectResponse = $purchaseResponse->getRedirectResponse();
        $this->assertInstanceOf(RedirectResponse::class, $redirectResponse);
        $this->assertEquals(Response::HTTP_FOUND, $redirectResponse->getStatusCode());
        $this->assertEquals($purchaseResponse->getRedirectUrl(), $redirectResponse->getTargetUrl());

        // output buffering
        ob_start();
        $redirectResult = $purchaseResponse->redirect();
        $contents = ob_get_contents();
        ob_end_clean();
    }

    /**
     * Test payment completion, to verify an incoming JWT from the CPP
     */
    public function testDoCppPaymentComplete()
    {
        $payload = $this->getJwtPayload();
        $jwt = $this->getJwt();

        $this->assertNotEmpty($jwt, "No JWT to test with");

        $completePurchaseRequest = $this->gateway->completePurchase([
            'jwt' => $jwt
        ]);

        $this->assertInstanceOf(CompletePurchaseRequest::class, $completePurchaseRequest);

        // ensure the token matches
        $this->assertEquals($jwt, $completePurchaseRequest->getJwt());
        // ensure the key matches
        $this->assertEquals($this->getJwtPublicKey(), $completePurchaseRequest->getJwtPublicKey());

        $completePurchaseResponse = $completePurchaseRequest->send();
        $this->assertInstanceOf(CompletePurchaseResponse::class, $completePurchaseResponse);

        $callback = function (CompletePurchaseResponse $response) {
            return true;
        };
        $response = $completePurchaseResponse->complete($callback);

        $this->assertInstanceOf(Response::class, $response);

        $response->send();
        $contents = ob_get_contents();

        $this->assertEquals(200, $response->getStatusCode());
    }

    /**
     * Request a refund and validate the response
     */
    public function testDoCppRefund()
    {

        // refund requires an access token
        $accessToken = $this->getAccessToken();

        // perform a refund
        $this->setMockHttpResponse('RefundSuccess.response');

        $paymentReference = 'here-be-monsters';
        $refundAmount = 105;
        $refundReason = "test refund reason";
        $refundRequest = $this->gateway->refund([
            'paymentReference' => $paymentReference,
            'refundAmount' => $refundAmount,
            'refundReason' => $refundReason
        ]);
        $this->assertInstanceOf(RefundRequest::class, $refundRequest);
        $refundRequest->setCurrentAccessToken($accessToken);

        // validate data
        $data = $refundRequest->getData();
        $this->assertEquals($refundAmount, $data['amount']);
        $this->assertEquals($refundReason, $data['refundReason']);

        // check status URL
        $refundUrl = $refundRequest->getRefundUrl();
        $this->assertEquals(
            str_replace("/{{paymentReference}}/", "/{$paymentReference}/", $this->refundUrl),
            $refundUrl // the URL returned from the request
        );

        // validate response
        $refundResponse = $refundRequest->send();
        $this->assertInstanceOf(RefundResponse::class, $refundResponse);

        // validate refundResponse
        $refundReference = $refundResponse->getRefundReference();
        $this->assertEquals("it_be_received", $refundReference);
    }

    /**
     * Test the payment status handling
     */
    public function testDoCppPaymentStatus()
    {

        // refund requires an access token
        $accessToken = $this->getAccessToken();

        // perform a refund
        $this->setMockHttpResponse('PaymentStatusRequestSuccess.response');

        $paymentReference = 'here-be-monsters';
        $fetchTransactionRequest = $this->gateway->fetchTransaction([
            'paymentReference' => $paymentReference
        ]);
        $this->assertInstanceOf(FetchTransactionRequest::class, $fetchTransactionRequest);
        $fetchTransactionRequest->setCurrentAccessToken($accessToken);

        // validate data
        $data = $fetchTransactionRequest->getData();
        $this->assertEmpty($data);

        // check status URL
        $statusUrl = $fetchTransactionRequest->getStatusUrl();
        $this->assertEquals(
            str_replace("/{{paymentReference}}/", "/{$paymentReference}/", $this->statusUrl),
            $statusUrl // the URL returned from the request
        );

        // validate response
        $fetchTransactionResponse = $fetchTransactionRequest->send();
        $this->assertInstanceOf(FetchTransactionResponse::class, $fetchTransactionResponse);

        // validate refundResponse
        $paymentStatus = $fetchTransactionResponse->getPaymentStatus();
        $this->assertEquals("COMPLETED", $paymentStatus);
    }
}
