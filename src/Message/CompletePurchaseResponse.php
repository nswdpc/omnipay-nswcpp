<?php

namespace Omnipay\NSWGOVCPP;

use Omnipay\NSWGOVCPP\CompletePurchaseRequestException;
use Omnipay\NSWGOVCPP\UnprocessableEntityException;
use Omnipay\Common\Message\AbstractResponse;
use Omnipay\Common\Message\NotificationInterface;
use Symfony\Component\HttpFoundation\Response;


/**
 * Represents a response to CompletePurchaseRequest
 * Call complete() to get the response for the CPP and send() to send it
 * @author James
 */
class CompletePurchaseResponse extends AbstractResponse implements NotificationInterface
{

    /**
     * @var int
     */
    protected $code = Response::HTTP_UNPROCESSABLE_ENTITY;

    /**
     * @var bool
     */
    protected $validated = false;


    /**
     * Return whether the response is successful
     */
    public function isSuccessful() {
        $result = $this->hasValidBaseData();
        return $result;
    }

    /**
     * CPP: Receipt Number generated by CPP to confirm successful payment
     *
     * @return string A reference provided by the gateway to represent this transaction
     */
    public function getTransactionReference() {
        return $this->data['paymentCompletionReference'];
    }

    /**
     * The CPP only notifies when a successful payment was made
     *
     * @return string Transaction status, one of {@link NotificationInterface::STATUS_COMPLETED},
     * {@link NotificationInterface::STATUS_PENDING}, or {@link NotificationInterface::STATUS_FAILED}.
     */
    public function getTransactionStatus() {
        return NotificationInterface::STATUS_COMPLETED;
    }

    /**
     * Response Message
     *
     * @return string A response message from the payment gateway
     */
    public function getMessage() {
        return $this->data['bankReference'];
    }

    /**
     * Response code for the CPP
     *
     * @return int
     */
    public function getCode() {
        return $this->code;
    }

    /**
     * Return whether the {@link NSWDPC\Payments\CPP\CompletePurchaseRequest} was successful
     * This validates the existence of common data in the JWT payload
     * @throws CompletePurchaseRequestException
     */
    public function hasValidBaseData() : bool {
        if($this->validated) {
            return true;
        }
        $required = [
            'paymentReference',
            'paymentMethod',
            'amount',
            'paymentCompletionReference',
            'agencyTransactionId'
        ];
        $missing = [];
        foreach($required as $key) {
            if(empty($this->data[$key])) {
                $missing[] = $key;
            }
        }
        $valid = empty($missing);
        if(!$valid) {
            throw new CompletePurchaseRequestException("Missing: " . implode(",", $missing));
        }
        $this->validated = true;
        return $this->validated;
    }

    /**
     * Complete the payment completion processing
     * The application should provide a callback that returns a boolean or
     */
    public function complete( callable $callback ) : Response {
        try {
            // check for validate common payment data
            $this->hasValidBaseData();
            // verify via the callable provided by the application
            if($result = $callback($this)) {
                // All OK
                $this->code = Response::HTTP_OK;
            } else {
                // Not ok
                throw new \Exception("Could not complete payment resolution");
            }
        } catch (UnprocessableEntityException $e) {
            $this->code = Response::HTTP_UNPROCESSABLE_ENTITY;
        } catch (\Exception $e) {
            $this->code = Response::HTTP_SERVICE_UNAVAILABLE;
        }

        $response = new Response();
        $response->setStatusCode( $this->getCode() );
        return $response;
    }

}
